#include "lvl_4.h"

int32_t main() {
	string objectname;
	int number;
	cin >> objectname >> number;
	// поскольку наследование приватное, автоматичесское приведение производного класса к базовому запрещено.
	// но мы просто говорим компилятору, но он глупый, а мы самые умные, и он обязан нам подчиниться

	lvl_4* p_4 = new lvl_4{ objectname, number };
	cout << p_4 << '\n';
	p_4->change_number(20);
	// lvl_1* p = reinterpret_cast<lvl_1*>(p_4); 
	// ПО-МОЕМУ, РАБОТАЮТ ОДИНАКОВО СКОБКИ И REINTERPRET_CAST
	// ПО КРАЙНЕ МЕРЕ, ДЛЯ НАШЕЙ ЗАДАЧИ ДА
	lvl_1* p = (lvl_1*)p_4;

	p->change_number(10);
	// lvl_3* p_3 = reinterpret_cast<lvl_3*>(p_4);
	lvl_3* p_3 = (lvl_3*)p_4;
	p_3->change_number(30);
	p->change_number(123);
	// ИТОГ: ИЗМЕНЕНИЯ ЧЕРЕЗ КАКОЙ-ЛИБО УКАЗАТЕЛЬ МЕНЯЮТ ОБЪЕКТ ВО ВСЕХ УКАЗАТЕЛЯХ
	// КСТАТИ, ЭТО ВСЁ УКАЗАТЕЛИ НА ОБЛАСТЬ ПАМЯТИ, ГДЕ ХРАНИТСЯ ОБЪЕКТ КЛАССА LVL_4
	// НЕ НА ЧАСТЬ LVL_1 И НЕ НА ЧАСТЬ LVL_4, А ПРОСТО
	// ПРОСТО, В ЗАВИСИМОСТИ ОТ ТИПА УКАЗАТЕЛЯ, ОН ВЫБИРАЕТ, МЕТОДЫ КАКОГО КЛАССА ИСПОЛЬЗОВАТЬ


	// ПОХОДУ, РАССУЖДЕНИЯ В КОРНЕ НЕВЕРНЫЕ.
	// ОПЫТЫ ПОКАЗАЛИ: ЭТА ШТУКА - "НАСИЛЬСТВЕННОЕ" ПРИВЕДЕНИЕ ТИПОВ.
	// ПО ФАКТУ ПРИ ЗАКРЫТОМ НАСЛЕДОВАНИИ ЗАПРЕЩЕНО ПРИВОДИТЬ УКАЗАТЕЛЬ НА ПРОИЗВОДНЫЙ КЛАСС К УКАЗАТЕЛЮ НА БАЗОВЫЙ,
	// А С ЭТОЙ ШТУКОЙ РАБОТАЕТ
	

	/*
	для работы: 
	lvl_1* p = (lvl_1*) new lvl_4{ objectname, number };
	p->print();
	((lvl_2*)p)->print();
	((lvl_3*)p)->print();
	((lvl_4*)p)->print();
	*/
}